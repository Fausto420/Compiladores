// - LÉXICO -

// Ignorar espacios y saltos de línea
WS: /[ \t\r\n]+/
%ignore WS

// Regex
ID: /[A-Za-z_][A-Za-z_0-9]*/
CTE_FLOAT: /[0-9]+\.[0-9]+/
CTE_INT: /[0-9]+/
CTE_STRING: /"[^"\n]*"/

// Palabras clave
PROGRAM: "program"
VARS: "vars"
VOID: "void"
MAIN: "main"
END: "end"
IF: "if"
ELSE: "else"
WHILE: "while"
DO: "do"
PRINT: "print"
RETURN: "return"
INT: "int"
FLOAT: "float"

// Operadores y separadores
EQUAL: "=="
NOTEQUAL: "!="
ASSIGN: "="
GREATER: ">"
LESS: "<"
PLUS: "+"
MINUS: "-"
STAR: "*"
SLASH: "/"
COLON: ":"
COMMA: ","
SEMICOL: ";"

// Agrupadores
LPAREN: "("
RPAREN: ")"
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"

// - SINTAXIS -

start: program

// Programa completo
program: PROGRAM ID SEMICOL vars_section? funcs_section MAIN body END

// Tipos básicos (para variables y funciones con tipo)
type: INT | FLOAT

// Sección de variables globales o locales
vars_section: VARS COLON decvar+
decvar: id_list COLON type SEMICOL
id_list: ID (COMMA ID)*

// - FUNCIONES -

// Regla para el tipo de retorno de la función:
// puede ser VOID (función sin valor) o un tipo numérico (INT/FLOAT)
func_return_type: VOID | type

// Declaración de función:
funcs_section: func_decl*
func_decl: func_return_type ID LPAREN params? RPAREN LBRACKET vars_section? body RBRACKET SEMICOL

// Parámetros formales
params: param (COMMA param)*
param: ID COLON type

// - BODY Y ESTATUTOS -

body: LBRACE stmt_list RBRACE
stmt_list: statement*

// return_stmt como un estatuto más
statement: assign | condition | cycle | fcall | print_stmt | return_stmt | body

// Asignación:  id = expresión ;
assign: ID ASSIGN expression SEMICOL

// if (expresión) { ... } [else { ... }] ;
condition: IF LPAREN expression RPAREN body (ELSE body)? SEMICOL

// while (expresión) do { ... } ;
cycle: WHILE LPAREN expression RPAREN DO body SEMICOL

// Llamada a función como estatuto: foo(a, b);
fcall: ID LPAREN args RPAREN SEMICOL
args: expression (COMMA expression)*

// NUEVO: return [expresión] ;
// - En funciones VOID se usará "return;"
// - En funciones con tipo se usará "return expresión;"
return_stmt: RETURN expression? SEMICOL

// Print
print_stmt: PRINT LPAREN print_args RPAREN SEMICOL
print_args: CTE_STRING | expression (COMMA CTE_STRING)?

// - EXPRESIONES -

expression: simple_expr rel_tail?
rel_tail: (GREATER | LESS | NOTEQUAL | EQUAL) simple_expr

simple_expr: term ((PLUS | MINUS) term)*
term: factor ((STAR | SLASH) factor)*

factor: LPAREN expression RPAREN | sign_opt primary
sign_opt: (PLUS | MINUS)?

// primary incluye id, constantes y llamada a función como expresión
primary: ID call_suffix? | number

// Si no aparece, el ID se trata como variable
call_suffix: LPAREN args RPAREN

number: CTE_INT | CTE_FLOAT
